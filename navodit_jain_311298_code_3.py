# -*- coding: utf-8 -*-
"""preprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NDn1j4SFkeraNozRbr1P-zX1Wudticqv

Importing Libraries
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler
from sklearn.linear_model import LogisticRegression

"""Loading the dataset"""

raw_data = pd.read_csv('drive/My Drive/data.csv',index_col=0)
raw_data.head()

"""**Exploratory Data Analysis**"""

# Checking for missing values
raw_data.isnull().sum()

"""Bivariate Analysis"""

sns.pairplot(raw_data,hue='is_goal')
plt.show()

"""Missing values treatment"""

raw_data.team_id.value_counts()

# drop columns which do not contribute to predictions
raw_data.drop('match_event_id',inplace=True,axis=1)
raw_data.drop('team_name',inplace=True,axis=1)
raw_data.drop('date_of_game',inplace=True,axis=1)
raw_data.drop('lat/lng',inplace=True,axis=1)
raw_data.drop('team_id',inplace=True,axis=1)

raw_data.shape

# Filling missing shot_id_numbers
raw_data.shot_id_number.interpolate(inplace=True)
# checking for null values
raw_data.shot_id_number.isnull().sum()

raw_data.boxplot(figsize = [10,5],column='distance_of_shot',by=['range_of_shot'])
raw_data.boxplot(figsize = [10,5],column='distance_of_shot',by=['shot_basics'])

table2 = raw_data.pivot_table(values='distance_of_shot' ,columns='range_of_shot', aggfunc=np.median)
table1 = raw_data.pivot_table(values='distance_of_shot' ,columns='shot_basics', aggfunc=np.median)
# Define function to return value of this pivot_table 
def fage(x):
  if str(x['shot_basics']) != 'nan':
    return table1.loc['distance_of_shot',x['shot_basics']]
  elif str(x['range_of_shot'])!= 'nan':
    return table2.loc['distance_of_shot',x['range_of_shot']]
  else:
    return x['distance_of_shot.1']
# Replace missing values 
raw_data['distance_of_shot'].fillna(raw_data[raw_data['distance_of_shot'].isnull()].apply(fage, axis=1), inplace=True)

raw_data = raw_data[raw_data['distance_of_shot'].notnull()]

raw_data.boxplot(figsize = [10,5],column='location_x',by=['area_of_shot'])
raw_data.boxplot(figsize = [10,5],column='location_y',by=['area_of_shot'])

table = raw_data.pivot_table(values=['location_x','location_y'] ,columns='area_of_shot', aggfunc=np.median)
def lacx(x):
  if str(x['area_of_shot']) != 'nan':
    return table.loc['location_x',x['area_of_shot']]
  else:
    return None
def lacy(x):
  if str(x['area_of_shot']) != 'nan':
    return table.loc['location_y',x['area_of_shot']]
  else:
    return None

raw_data['location_x'].fillna(raw_data[raw_data['location_x'].isnull()].apply(lacx, axis=1), inplace=True)
raw_data['location_y'].fillna(raw_data[raw_data['location_y'].isnull()].apply(lacy, axis=1), inplace=True)

raw_data['location_x'].fillna(raw_data['location_x'].median(), inplace=True)
raw_data['location_y'].fillna(raw_data['location_y'].median(), inplace=True)

raw_data.boxplot(figsize = [20,5],column='power_of_shot',by=['type_of_shot'])
raw_data.boxplot(figsize = [10,5],column='power_of_shot',by=['type_of_combined_shot'])

table1 = raw_data.pivot_table(values= 'power_of_shot' ,columns='type_of_shot', aggfunc=np.median)
table2 = raw_data.pivot_table(values= 'power_of_shot' ,columns='type_of_combined_shot', aggfunc=np.median)
def powerofshot(x):
  if str(x['power_of_shot.1']) != 'nan' and x['power_of_shot.1']<=7.0:
    return x['power_of_shot.1']
  elif str(x['type_of_shot']) != 'nan':
    return table1.loc['power_of_shot',x['type_of_shot']]
  else:
    return table2.loc['power_of_shot',x['type_of_combined_shot']]
  
raw_data['power_of_shot'].fillna(raw_data[raw_data['power_of_shot'].isnull()].apply(powerofshot, axis=1), inplace=True)
raw_data['power_of_shot'].isnull().sum()

mapp = pd.Series(raw_data['shot_basics'].values,index=raw_data['range_of_shot']).to_dict()
raw_data.pivot_table(values='is_goal',index=['shot_basics'],aggfunc=lambda x: x.mean())

raw_data['shot_basics'].value_counts()

def shotbasics(x):
  if str(x['range_of_shot']) != 'nan':
    return mapp[x['range_of_shot']]
  else:
    return 'Mid Range'
  
raw_data['shot_basics'].fillna(raw_data[raw_data['shot_basics'].isnull()].apply(shotbasics, axis=1), inplace=True)
raw_data['shot_basics'].isnull().sum()

# drop useless columns
raw_data.drop('area_of_shot',inplace=True,axis=1)
raw_data.drop('range_of_shot',inplace=True,axis=1)
raw_data.drop('remaining_min.1',inplace=True,axis=1)
raw_data.drop('remaining_sec.1',inplace=True,axis=1)
raw_data.drop('power_of_shot.1',inplace=True,axis=1)
raw_data.drop('knockout_match.1',inplace=True,axis=1)
raw_data.drop('distance_of_shot.1',inplace=True,axis=1)

ko = pd.Series(raw_data['knockout_match'].values,index=raw_data['match_id']).to_dict()
def kom(x):
  return ko[x['match_id']]

raw_data['knockout_match'].fillna(raw_data[raw_data['knockout_match'].isnull()].apply(kom, axis=1), inplace=True)
raw_data['knockout_match'].fillna(0, inplace=True)
raw_data['knockout_match'].isnull().sum()

gs = pd.Series(raw_data['game_season'].values,index=raw_data['match_id']).to_dict()
def gss(x):
  return gs[x['match_id']]

raw_data['game_season'].fillna(raw_data[raw_data['game_season'].isnull()].apply(gss, axis=1), inplace=True)
raw_data['game_season'].fillna(method='ffill',inplace=True)
raw_data['game_season'].isnull().sum()

ha = pd.Series(raw_data['home/away'].values,index=raw_data['match_id']).to_dict()
def home(x):
  return ha[x['match_id']]

raw_data['home/away'].fillna(raw_data[raw_data['home/away'].isnull()].apply(home, axis=1), inplace=True)
raw_data['home/away'].fillna(method='ffill',inplace=True)
raw_data['home/away'].isnull().sum()

# drop columns which are not useful
raw_data.drop('remaining_min',inplace=True,axis=1)
raw_data.drop('remaining_sec',inplace=True,axis=1)

raw_data.shape

raw_data['type_of_shot'].fillna('',inplace=True)
raw_data['type_of_combined_shot'].fillna('',inplace=True)

"""**Converting categorial  Variables**

Dummy variables are added to the dataframe to represent categorial variable as categorical variables are unsuitable for logistic regression model.
"""

# crete dummy variable for home game
raw_data['Home'] = raw_data['home/away'].str.contains('vs').map({True:1,False:0})
raw_data.drop('home/away',inplace=True,axis=1)

# create dummy variable for game_season
game_seasons = pd.get_dummies(raw_data['game_season'])
raw_data = pd.concat([raw_data, game_seasons], axis=1)
raw_data.drop('game_season',inplace=True,axis=1)

# create dummy variable for shot_basics
shot_basics = pd.get_dummies(raw_data['shot_basics'])
raw_data = pd.concat([raw_data, shot_basics], axis=1)
raw_data.drop('shot_basics',inplace=True,axis=1)

# create dummy variable for type_of_shot
shot_types = pd.get_dummies(raw_data['type_of_shot'])
raw_data = pd.concat([raw_data, shot_types], axis=1)
raw_data.drop(['type_of_shot',''],inplace=True,axis=1)

# create dummy variable for type_of_combined_shot
shot_types = pd.get_dummies(raw_data['type_of_combined_shot'],prefix='c')
raw_data = pd.concat([raw_data, shot_types], axis=1)
raw_data.drop(['type_of_combined_shot','c_'],inplace=True,axis=1)

raw_data.drop('match_id',inplace=True,axis=1)
raw_data.columns

# all missing values filled
raw_data.isnull().sum()

# Converting distace of shot to log scale for outlier removal
raw_data['distance_of_shot'] = np.log10(1+raw_data['distance_of_shot'])

raw_data.set_index('shot_id_number', inplace=True)
raw_data.head(10)

Y = raw_data['is_goal'].reset_index()
X = raw_data.loc[:,raw_data.columns != 'is_goal']

"""Normalisation"""

scaler = MinMaxScaler()
X = pd.DataFrame(scaler.fit_transform(X))
print(X.shape,Y.shape)

X['is_goal'] = Y['is_goal']
X['shot_id_number'] = Y['shot_id_number']
X.head()

train = X[X.is_goal.notnull()]
test = X[X.is_goal.isnull()]
print(train.shape)
print(test.shape)

train = train.set_index('shot_id_number')
test = test.set_index('shot_id_number')

# Saving the cleaned train and test data
train.to_csv('train.csv')
test.to_csv('test.csv')

train.columns

# Splitting the train and test data into x and y for logit
Y_train = np.array(train['is_goal'])
X_train = np.array(train.loc[:,train.columns != 'is_goal'])
X_test = np.array(test.loc[:,test.columns != 'is_goal'])
print(X_train.shape,Y_train.shape,X_test.shape)

X_test

"""**Model Building and Predictions**"""

model = LogisticRegression(random_state=0)
model.fit(X_train,Y_train) #Training

results = model.predict_proba(X_test)[:,0] #Predicting

# Saving the model

submission = pd.DataFrame()
submission['shot_id_number'] = test.reset_index()['shot_id_number'].astype(int)
submission['is_goal'] = pd.Series(results)
submission.to_csv('navodit_jain_311298_prediction_3.csv',index=False)